<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)packages\Rainbow.Core.2.0.0\lib\net452\Rainbow.dll" #>
<#@ assembly name="$(SolutionDir)packages\Rainbow.Storage.Yaml.2.0.0\lib\net452\Rainbow.Storage.Yaml.dll" #>
<#@ assembly name="$(SolutionDir)packages\RainbowCodeGeneration.0.2.0\lib\net452\RainbowCodeGeneration.dll" #>
<#@ assembly name="$(SolutionDir)packages\Sitecore.Kernel.8.2.160729\lib\net452\Sitecore.Kernel.dll" #>
<#@ assembly name="$(SolutionDir)packages\Sitecore.Logging.8.2.160729\lib\net452\Sitecore.Logging.dll" #>
<# 
// CONFIGURATION
var physicalFileStore = @"..\serialization\ModuleTypeX.ModuleNameX.Templates"; // the path to your serialisation items
var treeName = ""; // the name of the configuration you want to code-generate 
var treePath = "/sitecore/templates/SolutionX/ModuleTypeX/ModuleNameX"; // the matching path in Sitecore for the configuration

var templates = RainbowCodeGeneration.RainbowReader.GetTemplates(Host.ResolvePath(physicalFileStore), treeName, treePath);
#>
<#@ import namespace="RainbowCodeGeneration" #>
<#@ import namespace="Rainbow.Model" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated based on the Unicorn serialisation items
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// ReSharper disable InconsistentNaming
namespace SolutionX.ModuleTypeX.ModuleNameX.Models
{
	using System;
	using System.Collections.Generic;
	using System.Collections.Specialized;
	using System.Linq;
	using System.Text;
	using Glass.Mapper.Sc.Configuration.Attributes;
	using Glass.Mapper.Sc.Configuration;
	using Glass.Mapper.Sc.Fields;
	using Sitecore.Globalization;
	using Sitecore.Data;
	using Sitecore.Data.Items;
	using System.CodeDom.Compiler;
	using Epam.Sc.EngX.CodeGeneration.Domain;
<# try { foreach (var template in templates) { #>

	/// <summary>
	/// <#= StringExtensions.AsInterfaceName(template.Item.Name).Replace("_", string.Empty) #> Interface
	/// <para><#= template.Item.GetSharedField("__Short description") #></para>
	/// <para>Path: <#= template.Item.Path #></para> 
	/// <para>ID: <#= template.Item.Id #></para>  
	/// </summary>
	[SitecoreType(TemplateId="<#= template.Item.Id #>")] //, Cachable = true
	public partial interface <#= StringExtensions.AsInterfaceName(template.Item.Name).Replace("_", string.Empty) #> : IGlassBase
	{
<# foreach (var field in template.Fields) { #>
		[SitecoreField("<#=field.Name#>")]
		<#=GetGlassFieldType(field)#> <#= StringExtensions.AsPropertyName(field.Name) #>  {get; set;}
<#  } // foreach field #>
	}
	
	public static partial class <#= StringExtensions.AsInterfaceName(template.Item.Name).Replace("_", string.Empty) #>Constants
	{
		public const string TemplateIdString = "<#= template.Item.Id.ToString() #>";
		public static readonly ID TemplateId = new ID(TemplateIdString);
		public const string TemplateName = "<#= template.Item.Name #>";
	<#foreach(var field in template.Fields){#>
		
		public static readonly ID <#= StringExtensions.AsPropertyName(field.Name) #>FieldId = new ID("<#=field.Id.ToString()#>");
		public const string <#= StringExtensions.AsPropertyName(field.Name) #>FieldName = "<#=field.Name#>";	
	<#}#>}

	/// <summary>
	/// <#= template.Item.Name #>
	/// <para><#= template.Item.GetSharedField("__Short description") #></para>
	/// <para>Path: <#= template.Item.Path #></para>	
	/// <para>ID: <#= template.Item.Id #></para>	
	/// </summary>
	[SitecoreType(TemplateId="<#=template.Item.Id#>")]
	public partial class <#= StringExtensions.AsClassName(template.Item.Name).Replace("_", string.Empty) #> : GlassBase, <#= StringExtensions.AsInterfaceName(template.Item.Name).Replace("_", string.Empty) #> //, Cachable = true
    {
		/// <summary>
		/// The TemplateId string for <#= template.Item.Path #>
		/// </summary>
		public const string TemplateId = "<#= template.Item.Id #>";
<# foreach (var field in template.Fields) { #>
		[SitecoreField("<#=field.Name#>")]
		public <#=GetGlassFieldType(field)#> <#= StringExtensions.AsPropertyName(field.Name) #>  {get; set;}
<#  } // foreach field #>
	}
<#  } } catch (Exception ex){ Console.WriteLine(ex); } #>
}
<#+
public static string GetGlassFieldType(IItemData field)
{
	if (field != null)
    {
		// Pull out any 'type' param from the custom data field on the field in TDS
		string type = field.GetSharedField("Type");
		switch(type.ToLower())
		{
			case "tristate":
				return "TriState";
			case "checkbox":
				return "bool";

			case "date":
			case "datetime":
				return "DateTime";

			case "number":
				return "float";

			case "integer":
				return "int";

			case "treelist":
			case "treelistex":
			case "treelist descriptive":
			case "checklist":
			case "multilist":
	            return "IEnumerable<Item>";

			case "grouped droplink":
			case "droplink":
			case "lookup":
			case "droptree":
			case "reference":
			case "tree":
				return "Item";

			case "file":
				return "File";

			case "image":
				return "Image";

			case "rich text":
			case "html":
				return "string";

			case "general link":
				return "Link";

			case "single-line text":
			case "multi-line text":
			case "frame":
			case "text":
			case "memo":
			case "droplist":
			case "grouped droplist":
			case "valuelookup":
				return "string";	                                                                                                                            
			default:
				return "object /* UNKNOWN */";
		}
	}
	else 
	{
	   throw new Exception("There is no 'Type' field on the " + field.Name + " field.");
	}
}
#>